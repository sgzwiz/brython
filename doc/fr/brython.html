<html>
<head>
<title>Brython</title>
<meta http-equiv="content-type" content="text/html;charset=iso-8859-1">
<link rel="stylesheet" href="../doc_brython.css">
<script src="../../brython.js"></script>
</head>
<body onload="brython()">

<a name="syntaxe"><h3>Syntaxe</h3>
Brython est conforme à la syntaxe de Python 3
<ul>
<li>blocs délimités par l'indentation
<li>définition de listes par <code>[]</code> ou <code>list()</code>, de tuples par <code>()</code> ou <code>tuple()</code>, de dictionnaires par <code>{}</code> ou <code>dict()</code>, d'ensembles par <code>set()</code>
<li>listes en extansion : <code>[ expr for item in iterable if condition ]</code>
<li>opérateur ternaire : <code>x = r1 if condition else r2</code>
<li>la définition des fonctions peut comporter des valeurs par défaut et des arguments et mot-clés optionnels : <br><code>def foo(x,y=0,*args,**kw):</code>
<li>décompactage de listes ou de dictionnaires dans l'appel de fonctions : <code>x = foo(*args,**kw)</code>
</ul>

</ul>

<a name="integr"><h3>Mots clés et fonction intégrées</h3>

Brython supporte l'essentiel des mots-clés et des fonctions de Python 3 :
<ul><li>mots clés : <code>as assert break class continue def del elif else except False finally for from global if import lambda None pass return True try while </code>
<li>fonctions intégrées : <code>abs() all() any() bool() dict() dir() enumerate() eval() exec() filter() float() getattr() hasattr() input() int() isinstance() iter() len() list() map() max() min() next() object() print() range() reversed() round() set() setattr() slice() str() sum() tuple() zip()</code>
</ul>

Par défaut, <code>print()</code> affiche sur la console du navigateur, et les messages d'erreur sont également affichés sur cette console. <code>sys.stderr</code> et <code>sys.stdout</code> peuvent être affectés à un objet qui implémente une méthode <code>write()</code>, ce qui permet par exemple d'afficher les messages d'erreurs dans une fenêtre
<p>Pour lancer une impression sur imprimante, utiliser <code>win.print</code>

<p>Ne sont pas pris en charge : 
<ul>
<li>les mots-clés <code>is nonlocal with yield</code>
<li>parmi les fonctions intégrées :
<ul><li>certaines seront peut-être intégrées dans des versions futures : <code>ascii(), bin(), callable(), chr(), classmethod(), complex(), delattr(), divmod(), format(), frozenset(), globals() ,hex(), id(), locals(), ord(), pow(), repr(), sorted(), type(), vars()</code>
<li>d'autres ont peu de chances d'être intégrées : <code>bytearray(), bytes(), compile(), hash(), help(), memoryview(), property(), super(), __import__() </code>
<li>certaines ne sont pas pertinentes dans le contexte d'un navigateur : <code>open()</code>
<li>le type des nombres complexes n'est pas supporté
</ul>
</ul>
Contrairement à Python, on peut ajouter des attributs aux objects créés par la fonction intégrée <code>object()</code> :
<p><pre>x = object()
x.foo = 44
del x.foo
</pre>
<p>
Enfin, certains mots clés et fonctions intégrées adaptés au fonctionnement dans un navigateur sont ajoutés :
<ul>
<li>les fonctions intégrées <code>alert confirm prompt</code> correspondent à leur équivalent Javascript
<li>la fonction intégrée <code>ajax</code> permet l'exécution de requêtes HTTP en mode Ajax
<li>le mot clé <code>local_storage</code> représente le stockage local spécifié dans HTML5
<li>le mot clé <code>win</code> représente la fenêtre (objet <em>window</em> en JS) et <code>doc</code> représente le document HTML (<em>document</em> en JS)
<li>les fonctions intégrées <code>A ABBR ACRONYM ADDRESS APPLET AREA ARTICLE ASIDE AUDIO B BASE BASEFONT BDO BIG BLOCKQUOTE BODY BR BUTTON CANVAS CAPTION CENTER CITE CODE COL COLGROUP COMMAND DATALIST DD DEL DETAILS DFN DIR DIV DL DT EM FIELDSET FIGURE FONT FOOTER FORM FRAME FRAMESET H1 H2 H3 H4 H5 H6 HEAD HEADER HGROUP HR HTML I IFRAME IMG INPUT INS ISINDEX KBD LABEL LEGEND LI LINK MAP MARK MENU META METER NAV NOFRAMES NOSCRIPT OBJECT OL OPTGROUP OPTION OUTPUT P PARAM PRE PROGRESS Q RP RT RUBY S SAMP SCRIPT SECTION SELECT SMALL SPAN STRIKE STRONG STYLE SUB SUP TABLE TBODY TD TEXTAREA TFOOT TH THEAD TIME TITLE TR TT U UL VAR VIDEO</code> : chacune correspond à la balise HTML de même nom
</ul>
<hr>
<a name="htmldocs"><h3>Manipulation de documents HTML</h3>

Une page HTML est considérée comme un arbre, dont le sommet est représenté par le mot-clé <code>doc</code> et les noeuds sont soit des objets intégrés Python (chaines de caractères, entiers...) soit des objets créés par les fonctions correspondant aux balises HTML
<p>La syntaxe pour créer un objet (par exemple un lien hypertexte) est :
<blockquote><dl><dt><code>A(<i>[content,[attributes]]</i>)</code>
<dd><em>content</em> est le noeud "fils" de l'objet ; <em>attributes</em> est une suite de mots-clés correspondant aux attributs de la balise HTML. Ces attributs doivent être fournis avec la syntaxe Javascript, pas CSS : <em>backgroundColor</em> et pas <em>background-color</em>
</dl></blockquote>
Exemple :
<blockquote><pre>link1 = A('Brython',href='http://www.brython.info')
link2 = A(B('Python'),href='http://www.python.org')
</pre></blockquote>
<p>Pour l'attribut <em>style</em>, la valeur doit être un dictionnaire :
<blockquote><pre>d = DIV('Brython',style={'height':100,'width':200})</pre></blockquote>
<p>Pour éviter les conflits avec des mots-clés de Python, des attributs comme "class" ou "id" doivent être écrits avec une majuscule :
<blockquote><pre>d = DIV('Brython',Id="zone",Class="container")</pre></blockquote>

<p>On peut aussi créer un objet sans argument, puis le compléter :
<ul>
<li>pour ajouter un noeud enfant, utiliser l'opérateur <=
<li>pour ajouter des attributs, utiliser la syntaxe Python classique : <pre style="display:inline">objet.attribut = valeur</pre>
</ul>
<p>par exemple :
<p><pre>link = A()
link <= B('connexion')
link.href = 'http://exemple.com'
</pre>
<p>On peut aussi créer plusieurs éléments de même niveau par addition :
<p><pre>row = TR(TH('Nom')+TH('Prénom'))</pre>
<p>En combinant ces opérateurs et la syntaxe Python, voici comment créer une boite de sélection à partir d'une liste :
<p><pre>items = ['un','deux','trois']
sel = SELECT()
for i,elt in enumerate(items):
    sel <= OPTION(elt,value=i)
doc <= sel
</pre>
<p>A noter que la création d'une instance d'une classe HTML entraine la création d'un unique objet DOM. Si on affecte l'instance à une variable, on ne peut pas l'utiliser à plusieurs endroits. Par exemple avec ce code :
<p><pre>link = A('Python',href='http://www.python.org')
doc <= 'Site officiel de Python : '+link
doc <= P()+'Je répète : le site est '+link
</pre>
le lien ne sera montré que dans la deuxième ligne. Une solution est de cloner l'objet initial :
<p><pre>link = A('Python',href='http://www.python.org')
doc <= 'Site officiel de Python : '+link
doc <= P()+'Je répète : le site est '+link.clone()
</pre>

<p>Les instances des classes HTML ont des attributs de même nom que les objets DOM correspondants. On peut donc par exemple récupérer l'option sélectionnée par l'attribut <tt>selectedIndex</tt> de l'objet SELECT. Mais Brython ajoute quelques "sucres syntaxiques" pour rendre la manipulation plus conforme aux habitudes des codeurs Python
<ul>
<li>pour la recherche d'objets par leur identifiant, ou par leur nom de balise, on utilise la syntaxe suivante :
<ul>
<li><pre style="display:inline">doc[obj_id]</pre> renvoie l'objet d'après son identifiant, ou déclenche une exception <code>KeyError</code>
<li><pre style="display:inline">doc[A]</pre> renvoie une liste de tous les objets de type A (lien hypertexte) dans le document
</ul>
<li>le contenu d'un noeud DOM peut être lu ou modifié par les attributs <tt>text</tt> ou <tt>html</tt>, correspondant respectivement aux attributs <i>innerText</i> (ou <i>textContent</i>) et à <i>innerHTML</i> des objets DOM
<li>la collection <code>options</code> associée à un objet SELECT a l'interface d'une liste Python :
<ul>
<li>accès à une option par son index : <pre style="display:inline">option = elt.options[index]</pre>
<li>insertion d'une option à la position <em>index</em> : <pre style="display:inline">elt.options.insert(index,option)</pre>
<li>insertion d'une option en fin de liste : <pre style="display:inline">elt.options.append(option)</pre>
<li>suppression d'une option : <pre style="display:inline">del elt.options[index]</pre>
</ul>
<li>on peut itérer sur les enfants d'un objet par la syntaxe classique Python : <pre style="display:inline">for child in dom_object:</pre>
</ul>
<h3>Evénements</h3>
Pour attacher une fonction à un événement, on utilise la syntaxe 
<blockquote><pre>element.onclick = callback</pre></blockquote>
La fonction <tt>callback</tt> doit prendre un seul argument, qui est une instance de la classe <tt>DOMEvent</tt>. En plus des attributs DOM (qui peuvent avoir des noms différents selon les navigateurs), cet objet possède notamment les attributs suivants :
<p><table border=1>
<tr><th>Type d'événement</th><th>Attributs</th></tr>
<tr><td>clic ou déplacement de la souris</td><td><tt>x,y</tt> : position de la souris par rapport au bord supérieur gauche de la fenêtre</td></tr>
<tr><td>glisser-déposer (HTML5)</td><td><tt>data</tt> : donnée associée au déplacement</td></tr>
</table>
<p>Exemple :
<table>
<tr>
<td>
<pre>&lt;script type='text/python'&gt;
def mouse_move(ev):
    doc["trace"].value = '%s %s' %(ev.x,ev.y)

doc["zone"].onmousemove = mouse_move
&lt;/script&gt;

&lt;input id="trace" value=""&gt;
&lt;br&gt;&lt;textarea id="zone" rows=20 columns=30 style="background-color:gray"&gt;
passer la souris ici&lt;/textarea&gt;
</pre>
</td>
<td>
<pre><script type='text/python'>
def mouse_move(ev):
    doc["trace"].value = '%s %s' %(ev.x,ev.y)

doc["zone"].onmousemove = mouse_move
</script>

<input id="trace" value="">
<br><textarea id="zone" rows=7 columns=30 style="background-color:gray">
passer la souris ici</textarea>
</pre>
</td>
</tr>
</table>

<p><hr>
<a name="jsobjects"><h3>Utiliser des objets Javascript</h3>

Il faut gérer la période transitoire où Brython va cohabiter avec Javascript ;-)

<p>Un document HTML peut utiliser des scripts ou des librairies Javascript, et des scripts ou des librairies Python. Brython ne peut pas exploiter directement les objets Javascript : par exemple les attributs d'un objet sont récupérés par la méthode <tt>__getattr__</tt> de l'objet, qui n'existe pas pour les objets Javascript
<p>Pour les utiliser dans un script Python, il faut les transformer explicitement par la fonction intégrée <tt>JSObject</tt>
<p>Par exemple :

<blockquote>
<pre>
&lt;script type="text/javascript"&gt;
circle = {surface:function(r){return 3.14*r*r}}
&lt;/script&gt;
&lt;script type="text/python"&gt;
doc['result'].value = JSObject(circle).surface(10)
&lt;/script&gt;
</pre>
</blockquote>
<p><hr>
<a name="ajax"><h3>Ajax</h3>
La fonction intégrée <code>ajax()</code> renvoie un objet comparable à XMLHTTPRequest en Javascript, mais son interface est légèrement différente. Il possède les méthodes suivantes

<ul><li><code>open(<em>methode,url,async</em>)</code> : <em>methode</em> est la méthode HTTP utilisée pour la requête (habituellement GET ou POST), <em>url</em> est l'url appelée, <em>async</em> est un booléen qui indique si l'appel est asynchrone ou non
<li><code>set_header(<em>nom,valeur</em>)</code> : affecte la valeur <em>valeur</em> à l'entête <em>nom</em>
<li><code>set_timeout(<em>duree,fonction</em>)</code> : si la requête n'a pas renvoyé de réponse dans les <em>duree</em> secondes, annule la requête et exécute la <em>fonction</em>. Cette fonction ne prend pas d'argument
<li><code>send()</code> : lance la requête
</ul>
Pour interagir avec le serveur, il faut définir les attributs suivants, correspondant à chaque état de la variable <tt>readyState</tt> en Javascript :
<p><table cellspacing=0 cellpadding=0 border=1><tr><th>readyState</th><th>attribut</th></tr>
<tr><td>0</td><td><code>on_uninitialized</code></td></tr>
<tr><td>1</td><td><code>on_loading</code></td></tr>
<tr><td>2</td><td><code>on_loaded</code></td></tr>
<tr><td>3</td><td><code>on_interactive</code></td></tr>
<tr><td>4</td><td><code>on_complete</code></td></tr>
</table>
<p>L'attribut doit prendre pour valeur une fonction à un seul argument, qui est l'objet <code>ajax</code>. Cet objet possède les attributs suivants :
<ul>
<li><code>status</code> : un entier représentant le statut HTTP de la requête
<li><code>text</code> : la réponse du serveur sous forme de chaine de caractères (correspond à <em>responseText</em> en Javascript)
<li><code>xml</code> : la réponse du serveur sous forme d'objet DOM (correspond à <em>responseXML</em> en Javascript)
</ul>

<h4>Exemple</h4>
On suppose qu'il y a un DIV avec l'id "result" dans la page HTML
<p>
<pre>
def on_complete(req):
    if req.status==200 or req.status==0:
        doc["result"].html = req.text
    else:
        doc["result"].html = "error "+req.text
req = ajax()
req.on_complete = on_complete
req.set_timeout(timeout,err_msg)
req.open('POST',url,True)
req.set_header('content-type','application/x-www-form-urlencoded')
req.send(data)
</pre>
<hr>
<a name="locstor"><h3>Local storage</h3>

Le stockage local défini par HTML5 (classe <tt>Storage</tt> et objet <tt>localStorage</tt> de Javascript) est accessible sous la syntaxe <code>local_storage</code>. On l'utilise comme un dictionnaire Python classique, sauf que la recherche d'un mot clé inexistant renvoie <code>None</code> au lieu de déclencher une exception, et que la suppression d'une clé inexistante ne déclenche pas non plus d'exception

<h4>Exemple</h4>
<pre>local_storage['foo']='bar'
log(local_storage['foo'])
del local_storage['foo']
log(local_storage['foo']) # affiche None
</pre>

</body>
</html>
